---
title: سوالات
sidebar_position: 300
---

# سوالات

1. **سوال :** در یونیتی وقتی ما یک مقدار را از اینسپکتور تغییر می دهیم در کد از کدام مقدار استفاده می شود ؟
   مقدار اینسپکتور یا مقدار کد ؟

**جواب :**
در یونیتی وقتی یک مقدار **`[SerializeField]`** یا **public** را در Inspector تغییر می‌دهی، **مقدار Inspector** **بر کد اولویت دارد**.

یعنی:

-   اگر در کد یک مقدار پیش‌فرض بدهی:

    ```csharp
    [SerializeField] private int health = 100;
    ```

-   ولی در Inspector مقدار را تغییر دهی (مثلاً به 200)، **در زمان اجرا مقدار 200 استفاده خواهد شد** — نه 100.

---

### 🎯 چرا این اتفاق می‌افتد؟

یونیتی وقتی اسکریپت را روی یک GameObject قرار می‌دهی، یک کپی از مقادیر Serializable در **Scene** یا **Prefab** ذخیره می‌کند. این مقدار **مستقل از کد** می‌شود.

---

### 🧪 مثال:

```csharp
[SerializeField] private int speed = 10;

void Start()
{
    Debug.Log(speed);
}
```

اگر در Inspector مقدار `speed` را به 30 تغییر دهی، خروجی Console در اجرای بازی خواهد بود:

```
30
```

نه 10.

---

### 🧠 نکته مهم:

اگر مقدار را در Inspector یک بار هم عوض کرده باشی، حتی اگر دوباره در کد مقدار پیش‌فرض را تغییر دهی (مثلاً `= 20`)، مقدار جدید **در Inspector اعمال نمی‌شود** مگر اینکه:

-   مقدار را در Inspector دستی reset کنی (کلیک راست > Reset)
-   یا کامپوننت را حذف و دوباره اضافه کنی
-   یا از `OnValidate()` یا ابزارهای خاص برای تنظیم مجدد استفاده کنی

2. **سوال :** آیا می شود یک کلاس را درون یک کلاس دیگر تعریف کرد ؟

**جواب :** بله، در C# (و بنابراین در یونیتی)، **می‌توان یک کلاس را درون کلاس دیگر تعریف کرد**. به این نوع کلاس‌ها می‌گویند:

> **Nested Classes** (کلاس‌های تو در تو)

---

### ✅ ساختار کلی:

```csharp
public class OuterClass
{
    public class InnerClass
    {
        public void SayHello()
        {
            Debug.Log("سلام از کلاس داخلی!");
        }
    }
}
```

---

### 🧪 نحوهٔ استفاده:

```csharp
void Start()
{
    OuterClass.InnerClass obj = new OuterClass.InnerClass();
    obj.SayHello();
}
```

---

### 🎯 چند نکته مهم:

| ویژگی              | توضیح                                                                                                                   |
| ------------------ | ----------------------------------------------------------------------------------------------------------------------- |
| **سطح دسترسی**     | کلاس داخلی می‌تواند `public`، `private`، `protected` و غیره باشد. کلاس بیرونی فقط `public` یا `internal` می‌تواند باشد. |
| **استفاده معمول**  | وقتی کلاس داخلی فقط برای استفاده در داخل کلاس بیرونی تعریف شده (مثلاً برای ساختارهای کمکی)                              |
| **کاهش دید خارجی** | با `private class InnerClass` می‌توانی استفاده از آن را محدود به کلاس اصلی کنی                                          |

---

### 📌 مثال واقعی در یونیتی:

```csharp
public class Enemy : MonoBehaviour
{
    [System.Serializable]
    private class Stats
    {
        public int health;
        public int damage;
    }

    [SerializeField] private Stats stats;

    void Start()
    {
        Debug.Log("Health: " + stats.health);
    }
}
```

در این مثال:

-   کلاس `Stats` فقط درون کلاس `Enemy` وجود دارد.
-   با `[System.Serializable]` می‌توان آن را در **Inspector** دید.

---

3. **سوال :** نحوه ی نمایش کلاس در اینسپکتور ؟

**جواب :**

---

### ✅ **شرایط نمایش یک کلاس در Inspector**

| شرط                                                                 | توضیح                                                                       | نمونه معتبر                                         | نمونه نامعتبر                                      |
| ------------------------------------------------------------------- | --------------------------------------------------------------------------- | --------------------------------------------------- | -------------------------------------------------- |
| 🔹 `[System.Serializable]` روی کلاس باشد                            | الزاماً باید این Attribute بالای کلاس نوشته شود                             | `[System.Serializable] public class MyData { ... }` | `public class MyData { ... }` ❌                   |
| 🔹 کلاس نباید `static` یا `abstract` باشد                           | کلاس‌های ایستا یا انتزاعی نمایش داده نمی‌شوند                               | `public class MyData`                               | `public static class MyData` ❌                    |
| 🔹 کلاس باید **reference type** باشد (یعنی class، نه struct)        | برای struct هم میشه، ولی با محدودیت‌هایی (مثل عدم پشتیبانی از polymorphism) | `class MyData`                                      | —                                                  |
| 🔹 فیلد کلاس باید `public` یا `[SerializeField]` باشد               | در غیر این صورت یونیتی آن را serialize نمی‌کند                              | `[SerializeField] private MyData data;`             | `private MyData data;` ❌                          |
| 🔹 کلاس نباید generic باشد                                          | کلاس‌هایی مثل `class MyData<T>` نمایش داده نمی‌شوند                         | `class MyData`                                      | `class MyData<T>` ❌                               |
| 🔹 فیلدهای داخلی کلاس نیز باید `public` یا `[SerializeField]` باشند | تا بتوانند در Inspector دیده شوند                                           | `public int health;`                                | `private int health;` ❌ (بدون `[SerializeField]`) |
| 🔹 نباید از `property` بدون backing field استفاده شود               | فقط فیلدها نمایش داده می‌شوند، نه property صرف                              | `public int health;`                                | `public int Health { get; set; }` ❌               |

---

### 🧪 مثال کاملاً درست:

```csharp
using UnityEngine;

public class Player : MonoBehaviour
{
    [System.Serializable]
    public class Stats
    {
        public int health;
        [SerializeField] private int damage; // OK
    }

    [SerializeField] private Stats playerStats;
}
```

✔ این کد بدون خطا در Inspector فیلدی به نام `Player Stats` را نشان می‌دهد که شامل `health` و `damage` است.

---

3. تفاوت لیست و آرایه ؟

تفاوت‌های `List<T>` و آرایه (`T[]`) در C# زیاد هستند و دانستن آن‌ها مخصوصاً در Unity بسیار مهم است.

در ادامه همه‌ی تفاوت‌ها را به شکل **جدول** + **توضیح** + **مثال** برات آورده‌ام:

---

### ✅ جدول تفاوت‌های `List<T>` و آرایه `T[]`

| ویژگی                                   | `T[]` (آرایه)                              | `List<T>` (لیست)                             | توضیح                                                                          |
| --------------------------------------- | ------------------------------------------ | -------------------------------------------- | ------------------------------------------------------------------------------ |
| 🧠 **اندازه ثابت یا متغیر**             | ثابت                                       | متغیر (داینامیک)                             | آرایه بعد از تعریف دیگر قابل تغییر نیست ولی `List` می‌تواند عنصر اضافه/حذف کند |
| ⚙️ **دسترسی**                           | `arr[0]`                                   | `list[0]`                                    | هر دو از ایندکس پشتیبانی می‌کنند                                               |
| ➕ **افزودن عنصر**                      | ❌ (نیاز به کپی)                           | ✅ `list.Add(item)`                          | در آرایه باید آرایه جدید بسازی، ولی در لیست فقط `Add()`                        |
| ➖ **حذف عنصر**                         | ❌                                         | ✅ `Remove()`, `RemoveAt()`                  | آرایه حذف ندارد                                                                |
| 🔁 **مرتب‌سازی و جستجو**                | `Array.Sort(arr)`                          | `list.Sort()`                                | هر دو قابلیت مرتب‌سازی دارند ولی `List` ساده‌تر است                            |
| 📏 **تغییر اندازه**                     | ❌                                         | ✅ (داخلی انجام می‌دهد)                      | `List` خودکار افزایش سایز می‌دهد                                               |
| 🚀 **سرعت (Performance)**               | سریع‌تر                                    | کمی کندتر                                    | آرایه سبک‌تر و سریع‌تر است چون ساختار ساده‌تری دارد                            |
| 🧪 **LINQ و توابع کمکی**                | پشتیبانی دارد (بعد از `using System.Linq`) | پشتیبانی کامل                                | هر دو قابلیت LINQ دارند                                                        |
| 📋 **تبدیل به دیگری**                   | `list.ToArray()`                           | `arr.ToList()`                               | تبدیل دوطرفه ممکن است                                                          |
| 🔒 **خواندنی‌بودن در Inspector یونیتی** | ✅ `[SerializeField] public int[] arr;`    | ✅ `[SerializeField] public List<int> list;` | هر دو در یونیتی سریالایز می‌شوند                                               |
| 🔁 **foreach پشتیبانی**                 | ✅                                         | ✅                                           | هردو قابل پیمایش با foreach هستند                                              |

---

### 🧪 مثال عملی از تفاوت:

```csharp
int[] nums = { 1, 2, 3 };
// nums[3] = 4; ❌ خطا: Index خارج از محدوده است

List<int> list = new List<int> { 1, 2, 3 };
list.Add(4); // ✅ بدون مشکل
```

---

### 🧠 چه زمانی از هرکدام استفاده کنیم؟

| سناریو                                                      | پیشنهاد                |
| ----------------------------------------------------------- | ---------------------- |
| وقتی می‌دانی تعداد عناصر ثابت است                           | آرایه (`T[]`) بهتر است |
| وقتی می‌خواهی عناصر را در طول زمان اضافه/حذف کنی            | `List<T>` استفاده کن   |
| وقتی دنبال بهترین performance هستی (مثلاً در حلقه‌های زیاد) | آرایه سریع‌تر است      |
| وقتی کد ساده‌تر و قابل توسعه‌تر می‌خواهی                    | `List<T>` راحت‌تر است  |

---