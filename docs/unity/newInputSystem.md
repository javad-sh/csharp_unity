---
title: اینپوت سیستم جدید یونیتی
sidebar_position: 1
---


# اینپوت سیستم جدید یونیتی


## چرا باید به سیستم جدید مهاجرت کرد ؟
دلایل زیادی وجود دارد اما مهم ترین دلیل از نظر من بهینه بودن آن است. زیرا اینپوت سیستم جدید رویداد محور است. به این معنی که فقط زمانی فراخوانی می شود که رویدادی اتفاق بیفتد. برعکس روش قدیمی که در متد آپدیت تعریف می شد و باعث این می شود که در هر فریم برررسی کند که آیا مثلا تاچی اتفاق افتاده یا نه.

| مقایسه               | سیستم قدیمی (`Input`) | Input System جدید        |
| -------------------- | --------------------- | ------------------------ |
| خواندن ورودی         | در `Update()`         | رویدادمحور یا polling    |
| تعریف کلید           | با string (`"Jump"`)  | نوع‌محور (کلاس و Enum)   |
| گیم‌پد و تاچ         | نیاز به کدنویسی دستی  | بومی و ساده              |
| چند پلیر             | بسیار سخت و دستی      | با `PlayerInput` ساده    |
| حالت‌های مختلف کنترل | غیرممکن               | امکان‌پذیر با Action Map |
| توسعه‌پذیری          | پایین                 | بسیار بالا               |
| کدنویسی              | سریع ولی محدود        | کمی پیچیده‌تر ولی منعطف  |


نحوه ی استفاده :

1. برای استفاده اولین مرحله نصب پکیج input system است.
2. مرحله ی دوم ساخت یک Input Actions است.

فایل ساخته شده را به نامی که می خواهیم تغییر نام میدهیم (مثلا به نام player controler) و باز می کنیم.
قسمت action maps برای جدا کردن حالت های مختلف پلیر است. به این معنی که مثلا در خشکی دکمه ی بالا وظیفه ی رفتن پلیر به جلو را دارد اما در آب باید وظیفه ی شنا به سمت بالا را داشته باشد.
یعنی ما می توانیم حالت های مختلف را تعریف کنیم اگر قرار است دکمه ها در حالات مختلف وظایف متفاوتی داشته باشند.
در بازی می توانیم بین این اکشن مپ های مختلف بر اساس حالات بازی سوییچ کنیم.
مثلا یک حالت می سازیم به نام مبارزه.

بخش دوم بخشی است به نام action که در این بخش ما کارهایی که قرار است انجام شود (برای آن ورودی اینپوت می خواهیم) را می نویسیم.
بر اساس حالتی که ساختیم می توانیم اکشن های لگد و مشت و پرش و ... را بسازیم.


هر اکشن حداقل یک زیر مجموعه دارد. هر کدام از این زیرمجموعه های ورودی های ما هستند.
مثلا برای پریدن ما می توانیم 2 ورودی (زیرمجموعه) بسازیم. یکی دکمه ی space و دیگری دکمه کلیک چپ مثلا.

وقتی روی این ورودی ها کلیک کنیم در بخش سوم یعنی binding properties سه بخش را می بینیم.

## بخش binding 

این بخش برای ثبت وردی است که چی باشد موس و دکمه و ...

## بخش دوم : interactions

### ✳️ تعریف:

**Interaction**‌ها تعیین می‌کنن که *چه زمانی* یک اکشن **فعال (performed)** بشه، یا چه شرایطی باعث **canceled** یا **started** شدنش بشه.

این‌طوری کنترل بیشتری روی ورودی داری. مثلاً:

* پرش فقط وقتی اتفاق بیفته که دکمه رو بیشتر از ۰.۲ ثانیه نگه‌داری
* یا ضربه فقط وقتی ثبت بشه که دکمه سریع فشرده و رها بشه (tap)

---

## 💠 انواع Interactions

| Interaction             | کاربرد                                   | ویژگی                                   |
| ----------------------- | ---------------------------------------- | --------------------------------------- |
| **Press**               | فشار ساده یا فشردن تا رهاسازی            | مناسب کلیدها و دکمه‌ها                  |
| **Hold**                | نگه‌داشتن دکمه برای مدت مشخص             | قابل تنظیم (زمان دلخواه)                |
| **Tap**                 | فشار سریع و کوتاه                        | مثل "کلیک سریع"                         |
| **Slow Tap**            | فشار طولانی (برعکس Tap)                  | برای "شارژ کردن" حمله یا زدن ضربه سنگین |
| **Multi Tap**           | چند کلیک سریع پشت سر هم (مثل double tap) | قابل تنظیم روی تعداد                    |
| **Long Press** *(جدید)* | جایگزین ساده‌تر برای Hold                | در نسخه‌های جدید (از 1.4)               |

---

## 📘 توضیح کامل هر Interaction با مثال:

---

### 🔹 1. `Press`

**پیش‌فرض همهٔ Bindings‌هاست.**
در دو حالت اصلی کار می‌کنه:

* `Press Only`: وقتی دکمه فشرده میشه (`performed` روی down)
* `Release Only`: وقتی دکمه رها میشه (`performed` روی up)
* `Press and Release`: هر دو

**مثال:**

```csharp
myAction.performed += ctx => Debug.Log("Pressed!");
```

---

### 🔹 2. `Hold`

زمانی که کاربر دکمه را **برای مدت مشخصی نگه دارد**.

| گزینه           | توضیح                                             |
| --------------- | ------------------------------------------------- |
| **Hold Time**   | زمان لازم برای فعال شدن (`performed`)             |
| **Press Point** | حساسیت یا مقدار لازم فشار (برای گیم‌پد یا آنالوگ) |

**مثال کاربرد:**

* شارژ کردن حمله (اگر بیش از 1 ثانیه نگه‌داری → performed)

**کد:**

```csharp
if (ctx.interaction is HoldInteraction)
{
    Debug.Log("Held long enough");
}
```

---

### 🔹 3. `Tap`

فعال می‌شود **فقط اگر دکمه را سریع فشار و رها کنید** (زیر مدت خاصی)

| گزینه           | توضیح                            |
| --------------- | -------------------------------- |
| **Tap Time**    | ماکزیمم زمان بین press و release |
| **Press Point** | حساسیت فشار (برای آنالوگ‌ها)     |

**مثال کاربرد:**

* زدن سریع برای پرش، یا شلیک ساده

---

### 🔹 4. `Slow Tap`

دقیقا برعکس Tap — فقط وقتی اکشن رخ می‌دهد که دکمه را **طولانی‌تر از مقدار مشخصی نگه‌داری**.

**مثال کاربرد:**

* اجرای "ضربه سنگین" در مبارزه
* باز کردن منو با نگه‌داشتن یک دکمه

---

### 🔹 5. `Multi Tap`

اگر دکمه را **چند بار پشت سر هم** بزنید، اکشن فعال می‌شود.

| گزینه         | توضیح                           |
| ------------- | ------------------------------- |
| **Tap Count** | تعداد دفعات لازم برای فعال شدن  |
| **Max Delay** | بیشترین فاصله زمانی بین هر ضربه |

**مثال کاربرد:**

* دوبار ضربه برای "Dash"
* سه‌بار کلیک برای "حمله ویژه"

---

### 🔹 6. `Long Press` (جدید)

مثل `Hold` اما راحت‌تر استفاده می‌شود (نسخه‌های 1.4 به بعد).
بدون نیاز به ست کردن `Hold Time` در Inspector.

---

## 💡 نحوه تنظیم Interactions در Unity

1. فایل `*.inputactions` رو باز کن.
2. روی هر Binding کلیک کن.
3. در بخش **Interactions** از لیست کشویی نوع تعامل رو انتخاب کن.
4. می‌تونی چند Interaction روی یک Binding داشته باشی. به ترتیب بررسی می‌شن.

---

## 🧪 در کد چطور تشخیص بدیم کدوم Interaction اتفاق افتاده؟

```csharp
myAction.performed += ctx =>
{
    if (ctx.interaction is TapInteraction)
        Debug.Log("Tapped!");

    else if (ctx.interaction is HoldInteraction)
        Debug.Log("Held long enough!");

    else
        Debug.Log("Just Pressed");
};
```

---

## 🧠 نکات پیشرفته

* **چند Interaction برای یک Binding**؟ مشکلی نیست! Unity ترتیب رو رعایت می‌کنه.
* **اکشن با چند Binding** و Interaction متفاوت؟ عالیه برای پشتیبانی از ورودی‌های مختلف مثل:

  * تاچ: Tap → شلیک، Hold → حرکت
  * گیم‌پد: Press → پرش، Hold → پرش بلند


## بخش سوم : Processors

### 📌 تعریف:

**Processors** دادهٔ خام ورودی را قبل از رسیدن به اکشن، *تبدیل، تنظیم یا اصلاح* می‌کنند.

مثلاً:

* اعداد آنالوگ را نرمالایز می‌کنند (تبدیل از 0 تا 1)
* مقدار را وارونه می‌کنند
* فقط مقدار مثبت را رد می‌کنند

---

## 📁 ساختار کلی:

```plaintext
InputDevice -> [Binding Path] -> [Interactions] -> ✅ Processors -> Action
```

---

## 🧭 کاربردهای Processors:

| کاربرد         | Processor                         | مثال                           |
| -------------- | --------------------------------- | ------------------------------ |
| نرمال‌سازی جهت | `NormalizeVector2`                | حرکت آنالوگ با شدت ۱           |
| حذف نویز       | `Deadzone`                        | حذف لرزش دست در گیم‌پد         |
| وارونگی        | `Invert`                          | معکوس کردن محور Y برای دوربین  |
| مقیاس‌دهی      | `Scale`, `ScaleVector2`           | کند یا تند کردن حرکت           |
| تبدیل مقدار    | `Clamp`, `Invert`, `AxisDeadzone` | محدود کردن یا وارونه کردن      |
| نگاشت          | `Normalize`, `Clamp`, `Invert`    | تنظیم ورودی آنالوگ یا ژیروسکوپ |

---

## 💠 جدول کامل Processors رایج:

| نام Processor           | توضیح                                     | تنظیمات قابل اعمال   | مثال                               |
| ----------------------- | ----------------------------------------- | -------------------- | ---------------------------------- |
| **Invert**              | برعکس کردن مقدار (مثلاً -1 به 1)          | `invertX`, `invertY` | `Invert(invertY=true)`             |
| **Clamp**               | محدود کردن مقدار به بازه‌ای خاص           | `min`, `max`         | `Clamp(min=0, max=1)`              |
| **Scale**               | ضرب کردن مقدار در یک ضریب                 | `factor`             | `Scale(factor=2.5)`                |
| **ScaleVector2**        | اعمال Scale جداگانه برای X و Y            | `x`, `y`             | `ScaleVector2(x=1, y=-1)`          |
| **Normalize**           | نرمال‌سازی عددی به بازه \[0,1] یا \[-1,1] | —                    | `Normalize()`                      |
| **NormalizeVector2**    | وکتور دو بعدی را با طول ۱ نرمالایز می‌کند | —                    | `NormalizeVector2()`               |
| **Deadzone**            | حذف بازه مرده در stick/gamepad            | `min`, `max`         | `Deadzone(min=0.1, max=0.9)`       |
| **AxisDeadzone**        | مخصوص تک محور                             | `min`, `max`         | `AxisDeadzone(min=0.2)`            |
| **StickDeadzone**       | بهینه‌تر از Deadzone برای استیک‌ها        | `min`, `max`         | `StickDeadzone(min=0.1, max=0.95)` |
| **CompensateDirection** | جهت آنالوگ با قدرت ثابت                   | —                    | کم استفاده است                     |

---

:::tip
مثلا وقتی فقط جهت تاچ مهمه میشه از normalize استفاده کرد.
:::

## 🔧 نحوه استفاده در Unity:

1. فایل `.inputactions` را باز کن.
2. روی یک Binding کلیک کن.
3. قسمت پایین: **Processors** را باز کن.
4. از لیست کشویی، پردازشگر مورد نظر را اضافه کن.
5. مقدار پارامترها (مثلاً min/max) را تنظیم کن.

> ✅ می‌تونی چند Processor داشته باشی — به ترتیب اجرا می‌شن!

---

## 🧪 مثال کاربردی در بازی:

### 🎮 1. نرمال‌سازی حرکت آنالوگ (NormalizeVector2)

```csharp
// وقتی می‌خوای حرکت همیشه شدت کامل داشته باشه (مثل بازی‌های Top-Down):
// فرضاً با استیک گیم‌پد
Processors: NormalizeVector2
```

---

### 🎮 2. حذف لرزش دست در گیم‌پد (Deadzone)

```csharp
// جلوگیری از حرکت تصادفی در مقدار آنالوگ
Processors: StickDeadzone(min=0.15, max=0.95)
```

---

### 🎮 3. معکوس کردن محور دوربین (Invert Y)

```csharp
// برای تنظیمات "Invert Y axis" رایج در بازی‌ها
Processors: Invert(invertY=true)
```

---

### 🎮 4. محدود کردن زاویه یا شدت (Clamp)

```csharp
// اطمینان از اینکه مقدار بین 0 و 1 باقی بماند
Processors: Clamp(min=0, max=1)
```

---

## 📜 استفاده در کد (اختیاری):

اگر نمی‌خوای از فایل `.inputactions` استفاده کنی و همه چیز رو در کد می‌نویسی:

```csharp
var moveAction = new InputAction("Move", InputActionType.Value, "<Gamepad>/leftStick",
    interactions: "",
    processors: "NormalizeVector2,Deadzone(min=0.1,max=0.9)");

moveAction.Enable();
```

---

## ✅ جمع‌بندی

| مفهوم                         | Interaction         | Processor                |
| ----------------------------- | ------------------- | ------------------------ |
| *چه زمانی* ورودی ثبت شود      | ✔️                  | ❌                        |
| *چگونه مقدار ورودی تغییر کند* | ❌                   | ✔️                       |
| مثال                          | Tap، Hold، MultiTap | Clamp، Invert، Normalize |

