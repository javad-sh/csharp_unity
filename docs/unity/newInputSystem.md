---
title: اینپوت سیستم جدید یونیتی
sidebar_position: 1
---

# اینپوت سیستم جدید یونیتی

## چرا باید به سیستم جدید مهاجرت کرد ؟

دلایل زیادی وجود دارد اما مهم ترین دلیل از نظر من بهینه بودن آن است. زیرا اینپوت سیستم جدید رویداد محور است. به این معنی که فقط زمانی فراخوانی می شود که رویدادی اتفاق بیفتد. برعکس روش قدیمی که در متد آپدیت تعریف می شد و باعث این می شود که در هر فریم برررسی کند که آیا مثلا تاچی اتفاق افتاده یا نه.

| مقایسه               | سیستم قدیمی (`Input`) | Input System جدید        |
| -------------------- | --------------------- | ------------------------ |
| خواندن ورودی         | در `Update()`         | رویدادمحور یا polling    |
| تعریف کلید           | با string (`"Jump"`)  | نوع‌محور (کلاس و Enum)   |
| گیم‌پد و تاچ         | نیاز به کدنویسی دستی  | بومی و ساده              |
| چند پلیر             | بسیار سخت و دستی      | با `PlayerInput` ساده    |
| حالت‌های مختلف کنترل | غیرممکن               | امکان‌پذیر با Action Map |
| توسعه‌پذیری          | پایین                 | بسیار بالا               |
| کدنویسی              | سریع ولی محدود        | کمی پیچیده‌تر ولی منعطف  |

نحوه ی استفاده :

1. برای استفاده اولین مرحله نصب پکیج input system است.
2. مرحله ی دوم ساخت یک Input Actions است.

فایل ساخته شده را به نامی که می خواهیم تغییر نام میدهیم (مثلا به نام player controler) و باز می کنیم.
قسمت action maps برای جدا کردن حالت های مختلف پلیر است. به این معنی که مثلا در خشکی دکمه ی بالا وظیفه ی رفتن پلیر به جلو را دارد اما در آب باید وظیفه ی شنا به سمت بالا را داشته باشد.
یعنی ما می توانیم حالت های مختلف را تعریف کنیم اگر قرار است دکمه ها در حالات مختلف وظایف متفاوتی داشته باشند.
در بازی می توانیم بین این اکشن مپ های مختلف بر اساس حالات بازی سوییچ کنیم.
مثلا یک حالت می سازیم به نام مبارزه.

بخش دوم بخشی است به نام action که در این بخش ما کارهایی که قرار است انجام شود (برای آن ورودی اینپوت می خواهیم) را می نویسیم.
بر اساس حالتی که ساختیم می توانیم اکشن های لگد و مشت و پرش و ... را بسازیم.

هر اکشن حداقل یک زیر مجموعه دارد. هر کدام از این زیرمجموعه های ورودی های ما هستند.
مثلا برای پریدن ما می توانیم 2 ورودی (زیرمجموعه) بسازیم. یکی دکمه ی space و دیگری دکمه کلیک چپ مثلا.

وقتی روی این ورودی ها کلیک کنیم در بخش سوم یعنی binding properties سه بخش را می بینیم.

## بخش اول : binding

این بخش برای ثبت وردی است که چی باشد موس و دکمه و ...

## بخش دوم : interactions

### ✳️ تعریف:

**Interaction**‌ها تعیین می‌کنن که _چه زمانی_ یک اکشن **فعال (performed)** بشه، یا چه شرایطی باعث **canceled** یا **started** شدنش بشه.

این‌طوری کنترل بیشتری روی ورودی داری. مثلاً:

-   پرش فقط وقتی اتفاق بیفته که دکمه رو بیشتر از ۰.۲ ثانیه نگه‌داری
-   یا ضربه فقط وقتی ثبت بشه که دکمه سریع فشرده و رها بشه (tap)

---

## 💠 انواع Interactions

| Interaction             | کاربرد                                   | ویژگی                                   |
| ----------------------- | ---------------------------------------- | --------------------------------------- |
| **Press**               | فشار ساده یا فشردن تا رهاسازی            | مناسب کلیدها و دکمه‌ها                  |
| **Hold**                | نگه‌داشتن دکمه برای مدت مشخص             | قابل تنظیم (زمان دلخواه)                |
| **Tap**                 | فشار سریع و کوتاه                        | مثل "کلیک سریع"                         |
| **Slow Tap**            | فشار طولانی (برعکس Tap)                  | برای "شارژ کردن" حمله یا زدن ضربه سنگین |
| **Multi Tap**           | چند کلیک سریع پشت سر هم (مثل double tap) | قابل تنظیم روی تعداد                    |
| **Long Press** _(جدید)_ | جایگزین ساده‌تر برای Hold                | در نسخه‌های جدید (از 1.4)               |

---

## 📘 توضیح کامل هر Interaction با مثال:

---

### 🔹 1. `Press`

**پیش‌فرض همهٔ Bindings‌هاست.**
در دو حالت اصلی کار می‌کنه:

-   `Press Only`: وقتی دکمه فشرده میشه (`performed` روی down)
-   `Release Only`: وقتی دکمه رها میشه (`performed` روی up)
-   `Press and Release`: هر دو

**مثال:**

```csharp
myAction.performed += ctx => Debug.Log("Pressed!");
```

---

### 🔹 2. `Hold`

زمانی که کاربر دکمه را **برای مدت مشخصی نگه دارد**.

| گزینه           | توضیح                                             |
| --------------- | ------------------------------------------------- |
| **Hold Time**   | زمان لازم برای فعال شدن (`performed`)             |
| **Press Point** | حساسیت یا مقدار لازم فشار (برای گیم‌پد یا آنالوگ) |

**مثال کاربرد:**

-   شارژ کردن حمله (اگر بیش از 1 ثانیه نگه‌داری → performed)

**کد:**

```csharp
if (ctx.interaction is HoldInteraction)
{
    Debug.Log("Held long enough");
}
```

---

### 🔹 3. `Tap`

فعال می‌شود **فقط اگر دکمه را سریع فشار و رها کنید** (زیر مدت خاصی)

| گزینه           | توضیح                            |
| --------------- | -------------------------------- |
| **Tap Time**    | ماکزیمم زمان بین press و release |
| **Press Point** | حساسیت فشار (برای آنالوگ‌ها)     |

**مثال کاربرد:**

-   زدن سریع برای پرش، یا شلیک ساده

---

### 🔹 4. `Slow Tap`

دقیقا برعکس Tap — فقط وقتی اکشن رخ می‌دهد که دکمه را **طولانی‌تر از مقدار مشخصی نگه‌داری**.

**مثال کاربرد:**

-   اجرای "ضربه سنگین" در مبارزه
-   باز کردن منو با نگه‌داشتن یک دکمه

---

### 🔹 5. `Multi Tap`

اگر دکمه را **چند بار پشت سر هم** بزنید، اکشن فعال می‌شود.

| گزینه         | توضیح                           |
| ------------- | ------------------------------- |
| **Tap Count** | تعداد دفعات لازم برای فعال شدن  |
| **Max Delay** | بیشترین فاصله زمانی بین هر ضربه |

**مثال کاربرد:**

-   دوبار ضربه برای "Dash"
-   سه‌بار کلیک برای "حمله ویژه"

---

### 🔹 6. `Long Press` (جدید)

مثل `Hold` اما راحت‌تر استفاده می‌شود (نسخه‌های 1.4 به بعد).
بدون نیاز به ست کردن `Hold Time` در Inspector.

---

## 💡 نحوه تنظیم Interactions در Unity

1. فایل `*.inputactions` رو باز کن.
2. روی هر Binding کلیک کن.
3. در بخش **Interactions** از لیست کشویی نوع تعامل رو انتخاب کن.
4. می‌تونی چند Interaction روی یک Binding داشته باشی. به ترتیب بررسی می‌شن.

---

## 🧪 در کد چطور تشخیص بدیم کدوم Interaction اتفاق افتاده؟

```csharp
myAction.performed += ctx =>
{
    if (ctx.interaction is TapInteraction)
        Debug.Log("Tapped!");

    else if (ctx.interaction is HoldInteraction)
        Debug.Log("Held long enough!");

    else
        Debug.Log("Just Pressed");
};
```

---

## 🧠 نکات پیشرفته

-   **چند Interaction برای یک Binding**؟ مشکلی نیست! Unity ترتیب رو رعایت می‌کنه.
-   **اکشن با چند Binding** و Interaction متفاوت؟ عالیه برای پشتیبانی از ورودی‌های مختلف مثل:

    -   تاچ: Tap → شلیک، Hold → حرکت
    -   گیم‌پد: Press → پرش، Hold → پرش بلند

## بخش سوم : Processors

### 📌 تعریف:

**Processors** دادهٔ خام ورودی را قبل از رسیدن به اکشن، _تبدیل، تنظیم یا اصلاح_ می‌کنند.

مثلاً:

-   اعداد آنالوگ را نرمالایز می‌کنند (تبدیل از 0 تا 1)
-   مقدار را وارونه می‌کنند
-   فقط مقدار مثبت را رد می‌کنند

---

## 📁 ساختار کلی:

```plaintext
InputDevice -> [Binding Path] -> [Interactions] -> ✅ Processors -> Action
```

---

## 🧭 کاربردهای Processors:

| کاربرد         | Processor                         | مثال                           |
| -------------- | --------------------------------- | ------------------------------ |
| نرمال‌سازی جهت | `NormalizeVector2`                | حرکت آنالوگ با شدت ۱           |
| حذف نویز       | `Deadzone`                        | حذف لرزش دست در گیم‌پد         |
| وارونگی        | `Invert`                          | معکوس کردن محور Y برای دوربین  |
| مقیاس‌دهی      | `Scale`, `ScaleVector2`           | کند یا تند کردن حرکت           |
| تبدیل مقدار    | `Clamp`, `Invert`, `AxisDeadzone` | محدود کردن یا وارونه کردن      |
| نگاشت          | `Normalize`, `Clamp`, `Invert`    | تنظیم ورودی آنالوگ یا ژیروسکوپ |

---

## 💠 جدول کامل Processors رایج:

| نام Processor           | توضیح                                     | تنظیمات قابل اعمال   | مثال                               |
| ----------------------- | ----------------------------------------- | -------------------- | ---------------------------------- |
| **Invert**              | برعکس کردن مقدار (مثلاً -1 به 1)          | `invertX`, `invertY` | `Invert(invertY=true)`             |
| **Clamp**               | محدود کردن مقدار به بازه‌ای خاص           | `min`, `max`         | `Clamp(min=0, max=1)`              |
| **Scale**               | ضرب کردن مقدار در یک ضریب                 | `factor`             | `Scale(factor=2.5)`                |
| **ScaleVector2**        | اعمال Scale جداگانه برای X و Y            | `x`, `y`             | `ScaleVector2(x=1, y=-1)`          |
| **Normalize**           | نرمال‌سازی عددی به بازه \[0,1] یا \[-1,1] | —                    | `Normalize()`                      |
| **NormalizeVector2**    | وکتور دو بعدی را با طول ۱ نرمالایز می‌کند | —                    | `NormalizeVector2()`               |
| **Deadzone**            | حذف بازه مرده در stick/gamepad            | `min`, `max`         | `Deadzone(min=0.1, max=0.9)`       |
| **AxisDeadzone**        | مخصوص تک محور                             | `min`, `max`         | `AxisDeadzone(min=0.2)`            |
| **StickDeadzone**       | بهینه‌تر از Deadzone برای استیک‌ها        | `min`, `max`         | `StickDeadzone(min=0.1, max=0.95)` |
| **CompensateDirection** | جهت آنالوگ با قدرت ثابت                   | —                    | کم استفاده است                     |

---

:::tip
مثلا وقتی فقط جهت تاچ مهمه میشه از normalize استفاده کرد.
:::

## 🔧 نحوه استفاده در Unity:

1. فایل `.inputactions` را باز کن.
2. روی یک Binding کلیک کن.
3. قسمت پایین: **Processors** را باز کن.
4. از لیست کشویی، پردازشگر مورد نظر را اضافه کن.
5. مقدار پارامترها (مثلاً min/max) را تنظیم کن.

> ✅ می‌تونی چند Processor داشته باشی — به ترتیب اجرا می‌شن!

---

## 🧪 مثال کاربردی در بازی:

### 🎮 1. نرمال‌سازی حرکت آنالوگ (NormalizeVector2)

```csharp
// وقتی می‌خوای حرکت همیشه شدت کامل داشته باشه (مثل بازی‌های Top-Down):
// فرضاً با استیک گیم‌پد
Processors: NormalizeVector2
```

---

### 🎮 2. حذف لرزش دست در گیم‌پد (Deadzone)

```csharp
// جلوگیری از حرکت تصادفی در مقدار آنالوگ
Processors: StickDeadzone(min=0.15, max=0.95)
```

---

### 🎮 3. معکوس کردن محور دوربین (Invert Y)

```csharp
// برای تنظیمات "Invert Y axis" رایج در بازی‌ها
Processors: Invert(invertY=true)
```

---

### 🎮 4. محدود کردن زاویه یا شدت (Clamp)

```csharp
// اطمینان از اینکه مقدار بین 0 و 1 باقی بماند
Processors: Clamp(min=0, max=1)
```

---

## 📜 استفاده در کد (اختیاری):

اگر نمی‌خوای از فایل `.inputactions` استفاده کنی و همه چیز رو در کد می‌نویسی:

```csharp
var moveAction = new InputAction("Move", InputActionType.Value, "<Gamepad>/leftStick",
    interactions: "",
    processors: "NormalizeVector2,Deadzone(min=0.1,max=0.9)");

moveAction.Enable();
```

---

## ✅ جمع‌بندی

| مفهوم                         | Interaction         | Processor                |
| ----------------------------- | ------------------- | ------------------------ |
| _چه زمانی_ ورودی ثبت شود      | ✔️                  | ❌                       |
| _چگونه مقدار ورودی تغییر کند_ | ❌                  | ✔️                       |
| مثال                          | Tap، Hold، MultiTap | Clamp، Invert، Normalize |

با کلیک روی خود اکشن یه بخش به نام action properties را در سمت راست مشاهده می کنیم.
که این بخش هم خودش 3 بخش دارد.

## action properies

این بخش مشخص می‌کنه که _این اکشن چیه و چطور رفتار می‌کنه._

| ویژگی            | توضیح                                   | مثال                                            |
| ---------------- | --------------------------------------- | ----------------------------------------------- |
| **Name**         | نام اکشن (در کد و Inspector)            | `Move`, `Jump`, `Shoot`                         |
| **Action Type**  | نوع ورودی مورد انتظار                   | `Button`, `Value`, `Pass-Through`               |
| **Control Type** | نوع داده‌ای که انتظار می‌ره             | `Vector2`, `Button`, `Float`, `Quaternion`, ... |
| **Interactions** | رفتارهای وابسته به زمان (Tap, Hold,...) | `Tap`, `Hold`, ...                              |
| **Processors**   | پردازش مقدار (Normalize, Clamp, ...)    | `NormalizeVector2`, ...                         |

---

## 📌 1. Name (نام اکشن)

نام داخلی این اکشن است که در کد استفاده می‌کنی.

```csharp
playerInput.actions["Jump"]
```

---

## 📌 2. Action Type (نوع اکشن)

این یکی از **مهم‌ترین بخش‌هاست** چون تعیین می‌کنه که Unity چطور رفتار این اکشن رو تحلیل کنه.

### 🔹 انواع:

| نوع              | توضیح                                    | رفتار نمونه                                      |
| ---------------- | ---------------------------------------- | ------------------------------------------------ |
| **Button**       | دکمه‌های دیجیتال                         | فشار یک دکمه: A، Space، کلیک                     |
| **Value**        | مقادیر عددی                              | آنالوگ استیک، محور ماوس، تاچ                     |
| **Pass-Through** | نادیده گرفتن سیستم buffering/interaction | استفاده مستقیم از داده‌ی خام (مثلاً لمس چندتایی) |

---

### 📘 تفاوت Button vs. Value vs. Pass-Through

#### 🔹 `Button`

-   Unity روی آن زمان‌بندی و رویداد اعمال می‌کنه:

    -   `started`, `performed`, `canceled`

-   مناسب برای: پرش، شلیک، تایید

#### 🔹 `Value`

-   خروجی مقداری داره مثل:

    -   `float`, `Vector2`, `Vector3`

-   مناسب برای: حرکت، دوربین، فشار آنالوگ

#### 🔹 `Pass-Through`

-   مثل `Value` هست ولی بدون فیلتر شدن توسط Interactions
-   تمام ورودی‌ها مستقیماً عبور می‌کنن
-   مناسب برای لمس چندتایی، gyro، delta mouse

> ❗ وقتی `Pass-Through` رو انتخاب می‌کنی، دیگه نباید Interaction تنظیم کنی.

---

## 📌 3. Control Type (نوع کنترل یا دادهٔ خروجی)

| مقدار        | توضیح                              |
| ------------ | ---------------------------------- |
| `Button`     | مقدار `bool` (true/false)          |
| `Float`      | عددی (مثلاً فشار ماشه گیم‌پد)      |
| `Vector2`    | جهت، delta ماوس، swipe، ...        |
| `Vector3`    | جهت در فضای سه‌بعدی، ژیروسکوپ      |
| `Quaternion` | چرخش برای XR یا mobile orientation |

> ✳️ **نیازی نیست همیشه این رو دستی بزنی**؛ یونیتی معمولاً خودش اتوماتیک تعیین می‌کنه، مگر اینکه چند تفسیر ممکن باشه.

---

## 📌 4. Interactions (برای کل اکشن)

اگر بخوای Interactionها رو **در سطح اکشن** تنظیم کنی (نه روی Binding خاص)، اینجاست.

مثلاً:

```plaintext
Hold(duration=1.5)
```

ولی بهترین حالت تنظیم Interactions در هر **Binding** هست چون گاهی Binding‌های مختلف (تاچ، کیبورد، گیم‌پد) رفتارهای متفاوتی دارن.

---

## 📌 5. Processors (برای کل اکشن)

مثل بالا، اگر بخوای برای کل اکشن پردازش اعمال کنی (نه فقط روی یک Binding خاص)، اینجاست.

مثلاً:

```plaintext
NormalizeVector2
```

> ❗ اگر هم توی Action هم توی Binding پردازش‌گر گذاشتی، اول Binding اجرا می‌شه، بعد Action.

---

## 🧠 جمع‌بندی سریع Action Section

| فیلد         | توضیح                         | نکته مهم                               |
| ------------ | ----------------------------- | -------------------------------------- |
| Name         | نام داخلی در کد               | باید یونیک باشه                        |
| Action Type  | Button / Value / Pass-Through | پایه عملکرد Action                     |
| Control Type | نوع داده برگشتی               | بهتره خودت بزنی برای اطمینان           |
| Interactions | اعمال به همه Bindingها        | معمولاً بهتره در سطح Binding تنظیم بشه |
| Processors   | تبدیل داده نهایی              | مثلاً Normalize، Invert                |

:::note
Initial State Check چیست؟

## 🎛️ تعریف ساده:

**`Initial State Check`** یعنی:

> آیا این اکشن یا دستگاه **قبل از شروع بازی (در زمان فعال شدن)** باید **وضعیت اولیه (initial state)** خودش رو بررسی کنه یا نه؟

---

## 📍 کجا می‌بینیمش؟

این گزینه معمولاً در **Inspector**‌ کامپوننت `InputAction` یا `PlayerInput` ظاهر می‌شه، مخصوصاً زمانی که از `InputActionAsset` استفاده نمی‌کنی و `InputAction`‌ها رو دستی ساختی.

---

## 🧠 هدف:

Unity با فعال‌سازی `Initial State Check`، بررسی می‌کنه که:

-   آیا **دکمه‌ای قبل از شروع بازی فشار داده شده؟**
-   آیا **یک مقدار غیرصفر از قبل وجود داره؟** (مثل فشار استیک یا لمس فعال قبل از اجرای `Enable()`)

---

## ✳️ مثال کاربردی:

### فرض کن:

-   بازیکن قبل از شروع صحنه دکمه `Jump` رو نگه داشته
-   اگر `Initial State Check = true` باشه → Unity متوجه میشه که دکمه فشار داده شده، و اکشن `performed` می‌شه
-   اگر `false` باشه → یونیتی در اولین فریم اون دکمه رو نادیده می‌گیره

---

## 🧪 چه زمانی مفیده؟

| مورد                                                   | فعال باشه؟                                               |
| ------------------------------------------------------ | -------------------------------------------------------- |
| دکمه‌هایی مثل `Jump`, `Shoot`                          | ❌ بهتره غیرفعال باشه                                    |
| ورودی‌هایی که مقدار پیوسته دارن مثل `Vector2`, `Float` | ✅ مفیده برای بررسی مقدار اولیه (مثل جهت دوربین یا فشار) |
| شناسایی لمس فعال در شروع بازی                          | ✅ فعال باشه                                             |

---

## 🛠️ در کد:

وقتی از کد `InputAction.Enable()` استفاده می‌کنی، اگر Initial State Check فعال باشه، ممکنه همون لحظه اکشن `performed` بشه چون ورودی قبلاً فعال بوده.

مثلاً:

```csharp
moveAction.Enable(); // اگر joystick از قبل فشار داده شده باشه
```

با `Initial State Check = true` → متوجه می‌شی بازیکن داره حرکت می‌کنه
با `false` → نمی‌فهمی تا وقتی چیزی تغییر کنه

---

## ✅ جمع‌بندی

| مورد                          | توضیح                                                                                            |
| ----------------------------- | ------------------------------------------------------------------------------------------------ |
| **Initial State Check چیست؟** | بررسی وضعیت اولیه دیوایس‌ها یا اکشن‌ها در لحظه فعال‌سازی                                         |
| **چه کاری می‌کند؟**           | اگر ورودی از قبل فعال باشه، فوراً یک performed اجرا می‌کنه                                       |
| **چه زمانی فعال باشه؟**       | برای مقدارهای پیوسته مثل استیک/جهت/دوربین: ✅، برای دکمه‌های event-based: ❌ بهتره غیرفعال بمونه |

:::

## گزینه های اضافه کردن اکشن

## 📌 1. `Add Binding`

> 🔹 ساده‌ترین حالت اضافه کردن یک ورودی

### ✅ معنی:

یک **Binding معمولی** اضافه می‌کنه. یعنی یک ورودی مستقیم مثل:

-   `keyboard/space`
-   `mouse/leftButton`
-   `gamepad/buttonSouth`

### 🎯 کاربرد:

اکشن‌هایی که فقط به **یک دکمه یا ورودی مستقیم** نیاز دارن مثل:

-   پرش (`Jump`)
-   شلیک (`Shoot`)
-   باز کردن منو

---

## 📌 2. `Add Positive\Negative Binding`

> 🔹 برای ساختن محور (axis) با دو ورودی مخالف

### ✅ معنی:

این گزینه در واقع یک **Composite Binding از نوع `1D Axis`** ایجاد می‌کنه.

| مسیر     | کار                                 |
| -------- | ----------------------------------- |
| Negative | مثلاً `A` برای چپ یا `LeftArrow`    |
| Positive | مثلاً `D` برای راست یا `RightArrow` |

### 🎯 کاربرد:

وقتی می‌خوای دو دکمه **در یک محور کار کنن**، مثل:

-   حرکت چپ/راست
-   کاهش/افزایش مقدار
-   رفتن بین گزینه‌ها

### 🧪 خروجی:

`-1` برای کلید Negative، `+1` برای Positive، و `0` اگر هیچکدام فشار داده نشه.

---

## 📌 3. `Add Binding With One Modifier`

> 🔹 مثل ترکیب `Ctrl + A`

### ✅ معنی:

یه **Composite Binding از نوع `Button With One Modifier`** می‌سازه.

| نقش      | دکمه                                        |
| -------- | ------------------------------------------- |
| Modifier | دکمه‌ای که باید نگه داشته بشه، مثلاً `Ctrl` |
| Binding  | دکمه‌ی اصلی، مثلاً `A`                      |

### 🎯 کاربرد:

برای زمانی که می‌خوای **کاربر یک کلید خاص رو نگه داره و دکمه‌ی دیگری بزنه**. مثل:

-   `Ctrl + R` برای ریست
-   `Shift + Fire` برای تیر قدرتمند

---

## 📌 4. `Add Binding With Two Modifiers`

> 🔹 مثل ترکیب `Ctrl + Shift + A`

### ✅ معنی:

یه **Composite Binding از نوع `Button With Two Modifiers`** می‌سازه.

| نقش        | دکمه          |
| ---------- | ------------- |
| Modifier 1 | مثلاً `Ctrl`  |
| Modifier 2 | مثلاً `Shift` |
| Binding    | مثلاً `A`     |

### 🎯 کاربرد:

ورودی‌های حرفه‌ای‌تر مثل:

-   `Ctrl + Alt + Del`
-   `Shift + Ctrl + S` برای ذخیره خاص

---

## ✅ جمع‌بندی سریع:

| گزینه                            | نوع                               | توضیح سریع                    |
| -------------------------------- | --------------------------------- | ----------------------------- |
| `Add Binding`                    | ساده                              | یک دکمه/ورودی مستقیم          |
| `Add Positive\Negative Binding`  | Composite → 1D Axis               | برای دو دکمه مخالف در یک محور |
| `Add Binding With One Modifier`  | Composite → Button w/ 1 Modifier  | مثل `Ctrl + A`                |
| `Add Binding With Two Modifiers` | Composite → Button w/ 2 Modifiers | مثل `Ctrl + Shift + A`        |

---

## رفتار های متفاوت در کامپوننت player input

کامپوننت **`Player Input`** در یونیتی (Input System جدید) یک گزینه مهم به نام **Behavior** داره که تعیین می‌کنه:

> «وقتی یک اکشن اجرا شد، \*\*چطور به اسکریپت‌ها اطلاع بده؟» 📣

---

## 🔧 گزینه‌ی Behavior در Player Input

در Inspector از Player Input، بخش:

```
Behavior: [Send Messages | Invoke Unity Events | Broadcast Messages | Invoke C# Events]
```

هر کدوم از این رفتارها (Behaviors) روش خاصی برای _فراخوانی کد_ هنگام اجرای یک Input Action دارن.

الان همه رو دقیق و مقایسه‌ای برات توضیح می‌دم:

---

## ✅ 1. **Send Messages**

### 📌 معنی:

وقتی یک اکشن اجرا بشه، **متدی به اسم اون اکشن در همون گیم‌ابجکت صدا زده می‌شه.**

### 🎯 مثال:

اگر یه اکشن به اسم `Jump` داشته باشی، باید در اسکریپتی که روی همون گیم‌آبجکت هست بنویسی:

```csharp
void OnJump()
{
    Debug.Log("Jump called!");
}
```

> 🔸 یونیتی خودش `OnJump()` رو صدا می‌زنه، لازم نیست دستی متصل کنی.

### ⚠️ نکته:

-   اسم متد باید دقیقاً با `On<Name>` یکی باشه (وگرنه اجرا نمی‌شه).
-   فقط روی همون GameObject اجرا می‌شه.

---

## ✅ 2. **Broadcast Messages**

### 📌 معنی:

مثل `Send Messages` هست، اما فرقش اینه که:

> علاوه بر خود گیم‌آبجکت، **روی تمام فرزندانش (Child objects)** هم متد رو صدا می‌زنه.

### 🎯 مثال:

```csharp
void OnShoot()
{
    Debug.Log("Shoot received (any child)");
}
```

اگه این متد توی یکی از اسکریپت‌های child هم باشه، باز اجرا می‌شه.

---

## ✅ 3. **Invoke Unity Events**

### 📌 معنی:

در Inspector، برای هر Input Action یک **Event** نمایان می‌شه که می‌تونی دستی تعریف کنی چه متدی اجرا بشه.

### 🎯 مزیت:

-   نیازی به نوشتن متد با اسم خاص (`OnJump`) نداری
-   توی Inspector می‌تونی مشخص کنی کدوم متد صدا زده بشه
-   برای استفاده گرافیکی، Drag & Drop عالیه

### ⚠️ نکته:

-   کد باید `public` باشه تا توی Inspector دیده بشه
-   پارامتر متد باید `InputAction.CallbackContext` باشه:

```csharp
public void Jump(InputAction.CallbackContext ctx)
{
    if (ctx.performed)
        Debug.Log("Jump via Unity Event!");
}
```

---

## ✅ 4. **Invoke C# Events** (یا `C# Callback Interfaces`)

### 📌 معنی:

برای کسانی که کد‌نویسی جدی‌تر انجام می‌دن! این حالت **به سبک اینترفیس** عمل می‌کنه.

### 🎯 مراحل استفاده:

1. اکشن‌ها را در `.inputactions` تعریف کن
2. Generate C# Class رو فعال کن
3. کلاسی که می‌خوای اکشن‌ها رو بگیره، باید اینترفیس `IYourActionsNameActions` رو پیاده کنه

### 🧪 مثال:

اگر فایل `PlayerControls.inputactions` داشته باشی:

```csharp
public class MyPlayer : MonoBehaviour, PlayerControls.IPlayerActions
{
    PlayerControls controls;

    void Awake()
    {
        controls = new PlayerControls();
        controls.Player.SetCallbacks(this);
        controls.Player.Enable();
    }

    public void OnMove(InputAction.CallbackContext ctx)
    {
        Vector2 dir = ctx.ReadValue<Vector2>();
        Debug.Log("Move: " + dir);
    }

    public void OnJump(InputAction.CallbackContext ctx)
    {
        if (ctx.performed) Debug.Log("Jump!");
    }
}
```

> ✳️ این روش برای پروژه‌های تمیز و ماژولار خیلی توصیه می‌شه.

---

## 📊 جدول مقایسه رفتارها

| Behavior              | روش اجرا             | نیاز به نام خاص؟ | قابل Drag در Inspector؟ | مناسب برای                   |
| --------------------- | -------------------- | ---------------- | ----------------------- | ---------------------------- |
| `Send Messages`       | `OnActionName()`     | بله              | ❌                      | ساده‌ترین راه                |
| `Broadcast Messages`  | به کل درخت آبجکت     | بله              | ❌                      | اگر چند child باشن           |
| `Invoke Unity Events` | انتخاب دستی          | ❌               | ✅                      | برای طراحی بصری در Inspector |
| `C# Callbacks`        | اینترفیس/کلاس تولیدی | نه (اتوماتیک)    | ❌                      | پروژه‌های ماژولار و تمیز     |

---

## ✅ کدوم یکی برای تو خوبه؟

| نیاز تو                                | Behavior پیشنهادی                        |
| -------------------------------------- | ---------------------------------------- |
| سریع و ساده برای تست                   | Send Messages                            |
| دکمه‌ها و حرکات مختلف روی اجزای فرعی   | Broadcast Messages                       |
| استفاده از Inspector بدون کدنویسی زیاد | Invoke Unity Events                      |
| معماری حرفه‌ای و منعطف                 | C# Callback Interfaces (generated class) |

---

3. بعد از ساخت input action برای استفاده از کد دو راه وجود دارد.

اولی کد نویسی دستی است که خیلی safe نیست و پیشنهاد نمی شود.

مثالی از کد نویسی دستی :

```
using UnityEngine;
using UnityEngine.InputSystem;

public class PlayerController : MonoBehaviour
{
    public InputActionAsset inputAsset; // drag & drop فایل inputactions در Inspector
    private InputAction leftAction;

    void Awake()
    {
        // مپ و اکشن را دستی پیدا می‌کنیم
        var map = inputAsset.FindActionMap("basic");
        leftAction = map.FindAction("Left");

        leftAction.Enable();

        leftAction.performed += ctx => Debug.Log("⬅️ Left Pressed");
    }

    void OnDisable()
    {
        leftAction.Disable();
    }
}

```

روش دوم استفاده از فایل و کلاسی است که خود input action می سازد که این کار توصیه شده و امن تر است.

```
using UnityEngine;

public class PlayerController : MonoBehaviour
{
    private PlayerMovements input;

    void Awake()
    {
        input = new PlayerMovements();      // کلاس اتوماتیک
        input.basic.Enable();               // فعال کردن مپ basic

        input.basic.Left.performed += ctx => Debug.Log("⬅️ Left Pressed");
        //  ثبت یک "شنونده" (Listener) برای رویداد performed در اکشن Left
    }

    void OnDisable()
    {
        input.basic.Disable();
    }

    void OnDestroy()
    {
        input.Dispose();
        // برای  آزاد کردن منابع حافظهٔ کلاس PlayerMovements
    }
}

```

| وضعیت       | زمان وقوع                   | مثال                               |
| ----------- | --------------------------- | ---------------------------------- |
| `started`   | وقتی دکمه فشرده میشه        | انگشت پایین رفت                    |
| `performed` | وقتی ورودی کامل شد          | تاچ انجام شد یا نگه داشتن تکمیل شد |
| `canceled`  | اگر ورودی نیمه‌کاره رها بشه | انگشت قبل از hold کامل برداشته شد  |
